(self.webpackChunkretreon_website=self.webpackChunkretreon_website||[]).push([[418],{6568:function(e,t,n){"use strict";n.r(t),n.d(t,{contentTitle:function(){return h},default:function(){return g},frontMatter:function(){return u},metadata:function(){return p},toc:function(){return m}});var a=n(7462),r=n(3366),i=n(7294),o=n(3905),s=n(1140),c=n.n(s);function l(e){var t=e.children;return(0,i.useEffect)(c().contentLoaded,[]),i.createElement("div",{className:"mermaid"},t)}var d=["components"],u={title:"Creating Reducers"},h=void 0,p={unversionedId:"creating-reducers",id:"creating-reducers",isDocsHomePage:!1,title:"Creating Reducers",description:"This section assumes you know how to create actions.",source:"@site/docs/creating-reducers.md",sourceDirName:".",slug:"/creating-reducers",permalink:"/creating-reducers",editUrl:"https://github.com/retreon/website/edit/main/docs/creating-reducers.md",tags:[],version:"current",frontMatter:{title:"Creating Reducers"},sidebar:"someSidebar",previous:{title:"Creating Actions",permalink:"/creating-actions"},next:{title:"Advanced Usage",permalink:"/advanced-usage"}},m=[{value:"Updating State",id:"updating-state",children:[]},{value:"Error Handling",id:"error-handling",children:[{value:"Error Types",id:"error-types",children:[]}]},{value:"Async Actions",id:"async-actions",children:[]}],y={toc:m};function g(e){var t=e.components,n=(0,r.Z)(e,d);return(0,o.kt)("wrapper",(0,a.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"This section assumes you know ",(0,o.kt)("a",{parentName:"p",href:"creating-actions"},"how to create actions"),"."))),(0,o.kt)("p",null,"Retreon's ",(0,o.kt)("inlineCode",{parentName:"p"},"createReducer(...)")," export is the counterpart to ",(0,o.kt)("inlineCode",{parentName:"p"},"createAction(...)"),". It takes an initial state and a list of action handlers. We'll see how to define those in a moment."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const reducer = createReducer(initialState, (handleAction) => [\n  // Action handlers go here\n])\n")),(0,o.kt)("p",null,"I'm sure you can guess at the first parameter, it just describes the reducer's initial state. The second parameter is where all the magic happens. It describes how that initial state changes over time by subscribing to a list of events (actions) and updating the model in response (reducers)."),(0,o.kt)("p",null,"You can subscribe to actions with the ",(0,o.kt)("inlineCode",{parentName:"p"},"handleAction(...)")," callback. It ties a reducer to an action creator, so whenever that action gets dispatched, your handler is invoked. Any state changes in the handler are immediately applied."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// Create a counter reducer with a starting value of zero.\ncreateReducer(0, (handleAction) => [\n  // Increase by 1 whenever the `increment()` action is dispatched.\n  handleAction(increment, (state) => {\n    return state + 1\n  }),\n])\n")),(0,o.kt)("p",null,"The above example only changes state, but it also receives an action ",(0,o.kt)("inlineCode",{parentName:"p"},"payload"),". You may be used to receiving the entire action when writing reducers - be aware the only the payload is provided. This is quite intentional. Your reducer should never depend on ",(0,o.kt)("inlineCode",{parentName:"p"},"action.meta")," (that's the realm of middleware) and the action type is implied. What remains is the payload."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"createReducer(0, (handleAction) => [\n  handleAction(incrementBy, (state, quantity) => {\n    return state + quantity\n  }),\n])\n")),(0,o.kt)("h2",{id:"updating-state"},"Updating State"),(0,o.kt)("p",null,"Immutably updating state has historically been quite difficult, inefficient, and error prone. You end up making more changes than you intended, you may accidentally mutate state, and many libraries are obtusely verbose."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/immerjs/immer/"},"Immer")," makes state changes far more robust (and type safe!) by modeling changes as mutations on draft states. The library has quickly gained widespread adoption and official support by the Redux team. If you're unfamiliar with immer, take a moment to check it out."),(0,o.kt)("p",null,"Retreon automatically wraps all your reducers with immer. It's safe and encouraged to use mutation syntax."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"createReducer({ count: 0 }, (handleAction) => [\n  handleAction(increment, (state) => {\n    state.count += 1 // Thanks to immer, all mutation is safe.\n  }),\n])\n")),(0,o.kt)("p",null,"It may look jarring, but you'll get used to it very quickly."),(0,o.kt)("h2",{id:"error-handling"},"Error Handling"),(0,o.kt)("p",null,"If your action creator throws an error, retreon will dispatch an error action. You can listen for error events with ",(0,o.kt)("inlineCode",{parentName:"p"},"handleAction.error(...)"),"."),(0,o.kt)("p",null,"Say you've got an action creator that loads the user's theme preference, light or dark, but you want to handle the case where storage is unavailable. If the action succeeds, you get a theme. If it fails for any reason, you want to gracefully fall back to some default. You would use ",(0,o.kt)("inlineCode",{parentName:"p"},"handleAction(...)")," to successfully set a theme, and ",(0,o.kt)("inlineCode",{parentName:"p"},"handleAction.error(...)")," to use the fallback."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"createReducer({ theme: null }, (handleAction) => [\n  handleAction(loadTheme, (state, theme) => {\n    state.theme = theme // Success!\n  }),\n\n  handleAction.error(loadTheme, (state) => {\n    post.theme = DEFAULT_THEME // Failure. Use a fallback.\n  }),\n])\n")),(0,o.kt)("p",null,"All errors are reported. If the action creator fails for any reason, your error reducer will be notified."),(0,o.kt)("h3",{id:"error-types"},"Error Types"),(0,o.kt)("p",null,"If you're using TypeScript, you may notice that error payloads are always marked ",(0,o.kt)("inlineCode",{parentName:"p"},"unknown"),". That's because ",(0,o.kt)("inlineCode",{parentName:"p"},"throw")," types are inherently unknown - anything can go wrong."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"createReducer(initialState, (handleAction) => [\n  handleAction.error(fallibleAction, (state, error) => {\n    //                                       ^^^^^ unknown type\n  }),\n])\n")),(0,o.kt)("p",null,"If you're anticipating a specific error, then use (or create) a custom error class."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyCustomError extends Error {}\n\ncreateReducer(initialState, (handleAction) => [\n  handleAction.error(startRecording, (state, error) => {\n    if (error instanceof MyCustomError) {\n      // <your logic here>\n    }\n  }),\n])\n")),(0,o.kt)("p",null,"Custom errors are unusual in web development, but that's unfortunate. You can only win by having more descriptive errors. This works particularly well with TypeScript because after the ",(0,o.kt)("inlineCode",{parentName:"p"},"instanceof")," guard, you can safely access any custom fields on the error class. Use this to send arbitrary data to the error handler."),(0,o.kt)("h2",{id:"async-actions"},"Async Actions"),(0,o.kt)("p",null,"You can handle async actions the same way you would synchronous actions. Reducers for async actions are called when they finish, but occasionally you'll want something more immediate: a loading flag, an optimistic patch, an instant deletion. That's why retreon provides a hook for when an action starts, called ",(0,o.kt)("inlineCode",{parentName:"p"},"handleAction.optimistic(...)"),"."),(0,o.kt)(l,{mdxType:"Mermaid"},"graph LR; handleAction.optimistic--\x3ehandleAction; handleAction.optimistic--\x3ehandleAction.error;"),(0,o.kt)("p",null,"Optimistic reducers use the action input as the payload (that is, whatever you passed to the action when it was called)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"createReducer(initialState, (handleAction) => [\n  handleAction.optimistic(fetchUserDetails, (state) => {\n    state.loading = true // The request is in progress.\n  }),\n\n  handleAction(fetchUserDetails, (state, user) => {\n    state.loading = false // The request is finished!\n    state.users[user.id] = user\n  }),\n])\n")))}g.isMDXComponent=!0},1748:function(e,t,n){var a={"./locale":9234,"./locale.js":9234};function r(e){var t=i(e);return n(t)}function i(e){if(!n.o(a,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=i,e.exports=r,r.id=1748}}]);