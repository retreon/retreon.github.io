"use strict";(self.webpackChunkretreon_website=self.webpackChunkretreon_website||[]).push([[426],{6938:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return p}});var a=n(7462),r=n(3366),s=(n(7294),n(3905)),o=["components"],i={title:"Advanced Usage"},c=void 0,l={unversionedId:"advanced-usage",id:"advanced-usage",isDocsHomePage:!1,title:"Advanced Usage",description:"Retreon offers an escape hatch for situations where createAction(...) just doesn't cut it. You should use this sparingly, not because it's bad, but because it takes you off the beaten path.",source:"@site/docs/advanced-usage.md",sourceDirName:".",slug:"/advanced-usage",permalink:"/advanced-usage",editUrl:"https://github.com/retreon/website/edit/main/docs/advanced-usage.md",tags:[],version:"current",frontMatter:{title:"Advanced Usage"},sidebar:"someSidebar",previous:{title:"Creating Reducers",permalink:"/creating-reducers"},next:{title:"Style Guide",permalink:"/style-guide"}},u=[{value:"Action Factories",id:"action-factories",children:[{value:"Ordering Rules",id:"ordering-rules",children:[]}]}],d={toc:u};function p(e){var t=e.components,n=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Retreon offers an escape hatch for situations where ",(0,s.kt)("inlineCode",{parentName:"p"},"createAction(...)")," just doesn't cut it. You should use this sparingly, not because it's bad, but because it takes you off the beaten path."),(0,s.kt)("p",null,"Retreon is powered by async generator functions. Every ",(0,s.kt)("inlineCode",{parentName:"p"},"yield")," statement is a dispatch, and the return of ",(0,s.kt)("inlineCode",{parentName:"p"},"yield")," is whatever dispatch returned. In practice, this gives you the full power of ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-thunk/"},"redux-thunk")," while leveraging the expressiveness of modern JavaScript."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"async function* sequence() {\n  yield { type: 'first-action' }\n  await someEffect()\n  yield { type: 'second-action' }\n\n  return 'result'\n}\n\nstore.dispatch(sequence()) // Promise { \"result\" }\n")),(0,s.kt)("p",null,"These are just a few things that async generator functions can do:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Consume streams or observables into a sequence of dispatches."),(0,s.kt)("li",{parentName:"ul"},"Conditionally quit without dispatching an action."),(0,s.kt)("li",{parentName:"ul"},"Run code ",(0,s.kt)("em",{parentName:"li"},"after")," a dispatch."),(0,s.kt)("li",{parentName:"ul"},"Provide progress updates on long-running tasks.")),(0,s.kt)("p",null,"Further, because the result of ",(0,s.kt)("inlineCode",{parentName:"p"},"dispatch(...)")," is returned to ",(0,s.kt)("inlineCode",{parentName:"p"},"yield"),", you can infinitely extend this pattern through redux middleware. How about a special ",(0,s.kt)("inlineCode",{parentName:"p"},"yield")," value that returns redux state? Surprisingly easy:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// Redux middleware\nexport const GET_STATE = Symbol('middleware:GET_STATE')\n\nexport const middleware = store => next => action => {\n  return action === GET_STATE ? store.getState() : next(action)\n}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// Actions file\nimport { GET_STATE } from './middleware'\n\nasync function* selectState() {\n  const reduxState = yield GET_STATE\n}\n")),(0,s.kt)("p",null,"As you can see, generators offer a lot of power. Be careful not to overuse it."),(0,s.kt)("h2",{id:"action-factories"},"Action Factories"),(0,s.kt)("p",null,"The first problem you might encounter with async generators is what to dispatch. We've never shown how to create an ",(0,s.kt)("inlineCode",{parentName:"p"},'"optimistic"')," action outside the framework, nor does retreon want to expose those details. Not yet, at least."),(0,s.kt)("p",null,"The next problem is listening for actions. What do you pass to ",(0,s.kt)("inlineCode",{parentName:"p"},"handleAction(...)"),"? The generator? How would it know the action type?"),(0,s.kt)("p",null,"Action factories address both of those problems. It provides a small interface for creating action objects (error, success, optimistic) without needing to know the structure, and you can use it as a handle for ",(0,s.kt)("inlineCode",{parentName:"p"},"createReducer(...)")," while preserving type safety."),(0,s.kt)("p",null,"You'll use ",(0,s.kt)("inlineCode",{parentName:"p"},"createAction.factory(...)")," to instantiate a handle:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// Please don't actually call this \"factory\". Name it by what it does.\nexport const factory = createAction.factory('action-type')\n")),(0,s.kt)("p",null,"From there, you can dispatch errors, optimistic actions, and success events."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"async function* allActions() {\n  yield factory.optimistic('optimistic payload')\n  yield factory.success('success payload')\n  yield factory.failure(new Error('Something went wrong'))\n}\n")),(0,s.kt)("p",null,"Then pass the same handle to the reducer."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"createReducer(initialState, (handleAction) => [\n  handleAction.optimistic(factory, () => {}),\n  handleAction.error(factory, () => {}),\n  handleAction(factory, () => {}),\n])\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Note for TypeScript"),": Define generics to allow optimistic and success payloads. The payload parameters are disabled by default."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"createAction.factory<SuccessPayload, OptimisticPayload>('action-type')\n")),(0,s.kt)("h3",{id:"ordering-rules"},"Ordering Rules"),(0,s.kt)("p",null,"To preserve the sanity of your fellow developers, please observe the rules for actions:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Dispatch EITHER an error OR a success event (never both)."),(0,s.kt)("li",{parentName:"ul"},"NEVER dispatch an error twice for the same action."),(0,s.kt)("li",{parentName:"ul"},"NEVER dispatch a success event twice for the same action."),(0,s.kt)("li",{parentName:"ul"},"Optimistic updates must ALWAYS precede success/error events.")),(0,s.kt)("p",null,'If you must dispatch multiple actions of the same type (e.g. in a stream), use "optimistic".'))}p.isMDXComponent=!0}}]);